#include <inttypes.h>
#include <stdbool.h>

/**
 * Returns the 1 * (width + 2) transition from 3 * (width + 4) box
 * that is generated by top, mid, bot and padded with two empty cells.
 * Implementation below.
 * */
static inline uint64_t get_transition(uint64_t top, uint64_t mid, uint64_t bot,
                                      int width);
/**
 * `next_raw` occupies `width + 2` bits (bits 0..`width + 1`)
 * The transition is valid when the 0th bit and `width + 1`th bit is empty.
 * */
static inline bool is_valid_transition(uint64_t top, uint64_t mid, uint64_t bot,
                                       uint64_t next_raw, int width) {
  const uint64_t BITMASK_OF_BOUNDARY_BITS = (((uint64_t)1) << (width + 1)) | 1;
  return (next_raw & BITMASK_OF_BOUNDARY_BITS) == 0;
}

/**
 * `next_raw` occupies `width + 2` bits (bits 0..`width + 1`)
 * Bit 0 and bit `width + 1` is empty (because it's a valid transition)
 * Extract the middle `width` bits to get the next width row
 * */
static inline uint64_t postprocess_transition(uint64_t next_raw, int width) {
  return next_raw >> 1;
}

static inline uint64_t get_transition(uint64_t top, uint64_t mid, uint64_t bot,
                                      int width) {
  // Get the sum of a column by summing each bit from top/mid/bot
  uint64_t sh0_col_sum_b0 = top ^ mid ^ bot;
  uint64_t sh0_col_sum_b1 = (top & mid) | (top & bot) | (mid & bot);

  // Shift the sum
  uint64_t sh1_col_sum_b0 = sh0_col_sum_b0 << 1;
  uint64_t sh1_col_sum_b1 = sh0_col_sum_b1 << 1;
  uint64_t sh2_col_sum_b0 = sh0_col_sum_b0 << 2;
  uint64_t sh2_col_sum_b1 = sh0_col_sum_b1 << 2;

  // Add the non-shifted and shifted column sums to get the sum of a 3x3 grid.
  // Sum the 2^0s bit first
  uint64_t grid_sum_b0 = sh1_col_sum_b0 ^ sh0_col_sum_b0 ^ sh2_col_sum_b0;
  uint64_t grid_sum_b1_carry = (sh1_col_sum_b0 & sh0_col_sum_b0) |
                               (sh1_col_sum_b0 & sh2_col_sum_b0) |
                               (sh0_col_sum_b0 & sh2_col_sum_b0);
  // Sum the 2^1s bits (3 of them) and the carry bit just made
  // Sum pairs first
  uint64_t grid_sum_b1_0 = grid_sum_b1_carry ^ sh0_col_sum_b1;
  uint64_t grid_sum_b2_0 = grid_sum_b1_carry & sh0_col_sum_b1;
  uint64_t grid_sum_b1_1 = sh1_col_sum_b1 ^ sh2_col_sum_b1;
  uint64_t grid_sum_b2_1 = sh1_col_sum_b1 & sh2_col_sum_b1;
  // And sum the summed pairs
  uint64_t grid_sum_b1 = grid_sum_b1_0 ^ grid_sum_b1_1;
  uint64_t grid_sum_b2_carry = grid_sum_b1_0 & grid_sum_b1_1;
  uint64_t grid_sum_b2 = grid_sum_b2_0 ^ grid_sum_b2_1 ^ grid_sum_b2_carry;
  uint64_t grid_sum_b3 = (grid_sum_b2_0 & grid_sum_b2_1) |
                         (grid_sum_b2_0 & grid_sum_b2_carry) |
                         (grid_sum_b2_1 & grid_sum_b2_carry);

  // In Conway's game of life, a cell is alive next generation
  // Either when the grid sum is 3 (B3, S2)
  // or when the grid sum is 4 and the cell is alive this genereation (S3)
  uint64_t grid_sum_eq_3 =
      grid_sum_b0 & grid_sum_b1 & (~grid_sum_b2) & (~grid_sum_b3);
  uint64_t grid_sum_eq_4 =
      (~grid_sum_b0) & (~grid_sum_b1) & grid_sum_b2 & (~grid_sum_b3);

  uint64_t result = grid_sum_eq_3 | (grid_sum_eq_4 & (mid << 1));
  return result;
}